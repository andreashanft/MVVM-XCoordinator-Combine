//
//  DetailViewController.swift
//  XCoordinatorMVVM
//
//  Created by Andreas Hanft on 02.04.20.
//  Copyright ¬© 2020 andreashanft. All rights reserved.
//

import UIKit
import XCoordinator
import SwiftUI


#if DEBUG
// Provides two previews for light and dark mode using the Canvas
struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
      Group {
         PreviewWrapper(viewController: UINavigationController(rootViewController: DetailViewController(viewModel: DetailViewModel())))
            .environment(\.colorScheme, .light)

         PreviewWrapper(viewController: UINavigationController(rootViewController: DetailViewController(viewModel: DetailViewModel())))
            .environment(\.colorScheme, .dark)
      }
   }
}
#endif


// This is just a very simple mock to showcase styling.
enum DesignSystem {

    // The color enum should be autogenerated by for example SwiftGen
    // based on the named colors in the asset catalog.
    enum Color: String {
        case themeBright        = "ThemeBright"
        case themeDark          = "ThemeDark"
        case error              = "Error"
        case defaultBackground  = "DefaultBackground"
        case borderHighlight  = "BorderHighlight"
    }

    enum Font: String {
        case thonburi = "Thonburi"
        case palatino = "Palatino"
    }

    enum FontSize: CGFloat {
        case veryLarge  = 28.0
        case large      = 20.0
        case regular    = 16.0
        case small      = 12.0
        case verySmall  = 9.0
    }

    enum LineSpacing: CGFloat {
        case wide      = 1.6
        case regular   = 1.625
    }

    // Use enum to also provide a namespace for common values
    enum Spacing {
        static let `default`: CGFloat = 8.0
    }

    struct LabelStyle {
        let font: Font
        let fontSize: FontSize

        static let h1 = LabelStyle(font: .palatino, fontSize: .veryLarge)
        static let h2 = LabelStyle(font: .palatino, fontSize: .large)
    }

    struct ButtonStyle {
        let font: Font
        let fontSize: FontSize
        let titleColor: UIColor
        let backgroundColor: UIColor

        static let ¬¥default¬¥ = ButtonStyle(font: .palatino, fontSize: .regular, titleColor: .themeDark, backgroundColor: .themeBright)
        static let destructive = ButtonStyle(font: .palatino, fontSize: .regular, titleColor: .themeBright, backgroundColor: .error)
    }
}

extension DesignSystem.LabelStyle {
    static let bodytext = DesignSystem.LabelStyle(font: .thonburi, fontSize: .regular)
}


extension UILabel {
    func apply(style: DesignSystem.LabelStyle) {
        font = UIFont(name: style.font.rawValue, size: style.fontSize.rawValue)
    }
}


extension UIButton {
    func apply(style: DesignSystem.ButtonStyle) {
        backgroundColor = style.backgroundColor
        setTitleColor(style.titleColor, for: .normal)
        titleLabel?.font = UIFont(name: style.font.rawValue, size: style.fontSize.rawValue)
    }
}


extension UIColor {
    @nonobjc class var themeBright: UIColor         { makeColor(named: .themeBright) }
    @nonobjc class var themeDark: UIColor           { makeColor(named: .themeDark) }
    @nonobjc class var error: UIColor               { makeColor(named: .error) }
    @nonobjc class var defaultBackground: UIColor   { makeColor(named: .defaultBackground) }
    @nonobjc class var borderHighlight: UIColor     { makeColor(named: .borderHighlight) }

    static func makeColor(named colorName: DesignSystem.Color) -> UIColor {
        UIColor(named: colorName.rawValue) ?? .systemPink
    }
}

@propertyWrapper
public struct UsesAutoLayout<T: UIView> {
    public var wrappedValue: T {
        didSet {
            wrappedValue.translatesAutoresizingMaskIntoConstraints = false
        }
    }

    public init(wrappedValue: T) {
        self.wrappedValue = wrappedValue
        wrappedValue.translatesAutoresizingMaskIntoConstraints = false
    }
}

class DetailView: UIView {

    @UsesAutoLayout var label = UILabel()
    @UsesAutoLayout var button = UIButton()
    @UsesAutoLayout var stackView = UIStackView()

    var labels: [String] = [] {
        didSet {
            configureLabels(labels)
        }
    }

    init() {
        super.init(frame: .zero)

        setupViews()
        setupConstraints()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private func setupViews() {
        backgroundColor = .defaultBackground

        label.apply(style: .h1)
        label.backgroundColor = resolveBackgroundColor(with: traitCollection)
        addSubview(label)

        let resolvedColor = UIColor.borderHighlight.resolvedColor(with: traitCollection)
        button.layer.borderWidth = 3.0
        button.layer.borderColor = resolvedColor.cgColor
        button.apply(style: .destructive)
        addSubview(button)

        stackView.axis = .vertical
        stackView.alignment = .center
        stackView.distribution = .fill
        stackView.spacing = DesignSystem.Spacing.default
        addSubview(stackView)
    }

    private func configureLabels(_ labels: [String]) {
        stackView.subviews.forEach { $0.removeFromSuperview() }

        let firstLabelStyle = DesignSystem.LabelStyle(font: .palatino, fontSize: .small)
        for (i, labelText) in labels.enumerated() {
            let demoLabel = UILabel()
            let style = i == 0 ? firstLabelStyle : .bodytext
            demoLabel.apply(style: style)
            demoLabel.numberOfLines = i % 2 == 0 ? 0 : 1
            demoLabel.text = labelText
            stackView.addArrangedSubview(demoLabel)
        }
    }

    private func setupConstraints() {
        // Only extract magic numbers when they are used more than once
        let margin: CGFloat = 16.0

        NSLayoutConstraint.activate([
            label.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor, constant: 42),
            label.leadingAnchor.constraint(equalTo: safeAreaLayoutGuide.leadingAnchor, constant: margin),
            label.trailingAnchor.constraint(equalTo: safeAreaLayoutGuide.trailingAnchor, constant: margin),

            button.widthAnchor.constraint(equalToConstant: 180),
            button.heightAnchor.constraint(equalToConstant: 44),
            button.centerXAnchor.constraint(equalTo: centerXAnchor),
            button.centerYAnchor.constraint(equalTo: centerYAnchor),

            stackView.topAnchor.constraint(equalTo: button.bottomAnchor, constant: 40),
            stackView.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor)
        ])
    }

    private func resolveBackgroundColor(with traitCollection: UITraitCollection) -> UIColor {
        // Example how to manually adjust appearance based on interface style
        switch traitCollection.userInterfaceStyle {
        case .light:
            return .red
        case .dark:
            return .green
        case .unspecified:
            return .blue
        @unknown default:
            fatalError()
        }
    }
}


class DetailViewController: UIViewController {

    // MARK: Stored properties

    private lazy var detailView = DetailView()
    private var subscriptions = Subscriptions()
    private let viewModel: DetailViewModel

    init(viewModel: DetailViewModel) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func loadView() {
        view = detailView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setup()
        setupBindings()
    }

    private func setup() {

        // Setup specific to the view controller

        title = "Detail üîç"
        // tabBarItem = ...
        // supportedInterfaceOrientations = ...
    }

    private func setupBindings() {

        subscriptions.add([

            // Outputs
            viewModel.$headlineText.assign(to: \.label.text, on: detailView),
            viewModel.$buttonText.assign(to: \.button.defaultTitle, on: detailView),
            viewModel.$textLabels.assign(to: \.labels, on: detailView),

            // Inputs
            detailView.button.onTap.assign(to: \.backAction, on: viewModel),
        ])
    }
}
