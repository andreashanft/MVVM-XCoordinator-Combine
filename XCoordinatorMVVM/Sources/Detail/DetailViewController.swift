//
//  DetailViewController.swift
//  XCoordinatorMVVM
//
//  Created by Andreas Hanft on 02.04.20.
//  Copyright ¬© 2020 andreashanft. All rights reserved.
//

import UIKit
import XCoordinator
import SwiftUI


#if DEBUG
// Provides two previews for light and dark mode using the Canvas
struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
      Group {
         PreviewWrapper(viewController: UINavigationController(rootViewController: DetailViewController(viewModel: DetailViewModel())))
            .environment(\.colorScheme, .light)

         PreviewWrapper(viewController: UINavigationController(rootViewController: DetailViewController(viewModel: DetailViewModel())))
            .environment(\.colorScheme, .dark)
      }
   }
}
#endif


// This is just a very simple mock to showcase styling.
enum DesignSystem {

    // The color enum should be autogenerated by for example SwiftGen
    // based on the named colors in the asset catalog.
    enum Color: String {
        case themeWhite         = "ThemeWhite"
        case themeBlack         = "ThemeBlack"
        case error              = "Error"
        case defaultBackground  = "DefaultBackground"
    }

    enum Font: String {
        case thonburi = "Thonburi"
        case palatino = "Palatino"
    }

    enum FontSize: CGFloat {
        case veryLarge  = 28.0
        case large      = 20.0
        case regular    = 16.0
        case small      = 12.0
        case verySmall  = 9.0
    }

    enum LineSpacing: CGFloat {
        case wide      = 1.6
        case regular   = 1.625
    }

    // Use enum to also provide a namespace for common values
    enum Spacing {
        static let `default`: CGFloat = 8.0
    }

    struct LabelStyle {
        let font: Font
        let fontSize: FontSize

        static let h1 = LabelStyle(font: .palatino, fontSize: .veryLarge)
        static let h2 = LabelStyle(font: .palatino, fontSize: .large)
    }

    struct ButtonStyle {
        let font: Font
        let fontSize: FontSize
        let titleColor: UIColor
        let backgroundColor: UIColor

        static let ¬¥default¬¥ = ButtonStyle(font: .palatino, fontSize: .regular, titleColor: .themeBlack, backgroundColor: .themeWhite)
        static let destructive = ButtonStyle(font: .palatino, fontSize: .regular, titleColor: .themeWhite, backgroundColor: .error)
    }
}

extension DesignSystem.LabelStyle {
    static let bodytext = DesignSystem.LabelStyle(font: .thonburi, fontSize: .regular)
}


extension UILabel {
    func apply(style: DesignSystem.LabelStyle) {
        font = UIFont(name: style.font.rawValue, size: style.fontSize.rawValue)
    }
}


extension UIButton {
    func apply(style: DesignSystem.ButtonStyle) {
        backgroundColor = style.backgroundColor
        setTitleColor(style.titleColor, for: .normal)
        titleLabel?.font = UIFont(name: style.font.rawValue, size: style.fontSize.rawValue)
    }
}


extension UIColor {
    @nonobjc class var themeWhite: UIColor          { makeColor(named: .themeWhite) }
    @nonobjc class var themeBlack: UIColor          { makeColor(named: .themeBlack) }
    @nonobjc class var error: UIColor               { makeColor(named: .error) }
    @nonobjc class var defaultBackground: UIColor   { makeColor(named: .defaultBackground) }

    static func makeColor(named colorName: DesignSystem.Color) -> UIColor {
        UIColor(named: colorName.rawValue) ?? .systemPink
    }
}

extension UIView {

    var translatesAutoresizingMaskIntoConstraintsForSubviews: Bool {
        set {
            subviews.forEach { $0.translatesAutoresizingMaskIntoConstraints = newValue }
        }
        get {
            subviews.first?.translatesAutoresizingMaskIntoConstraints ?? false
        }
    }

    func activate(_ constraints: [NSLayoutConstraint]) {
        self.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate(constraints)
    }
}


class DetailView: UIView {

    let label = UILabel()
    let button = UIButton()
    let stackView = UIStackView()

    init() {
        super.init(frame: .zero)

        setupViews()
        setupConstraints()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private func setupViews() {
        backgroundColor = .defaultBackground

        label.apply(style: .h1)
        addSubview(label)
        button.apply(style: .destructive)
        addSubview(button)

        stackView.axis = .vertical
        stackView.alignment = .center
        stackView.distribution = .fill
        stackView.spacing = DesignSystem.Spacing.default
        addSubview(stackView)

        let firstLabelStyle = DesignSystem.LabelStyle(font: .palatino, fontSize: .small)
        for i in 0...3 {
            let demoLabel = UILabel()
            let style = i == 0 ? firstLabelStyle : .bodytext
            demoLabel.apply(style: style)
            demoLabel.numberOfLines = i % 2 == 0 ? 0 : 1
            demoLabel.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit"
            stackView.addArrangedSubview(demoLabel)
        }
    }

    private func setupConstraints() {
        // Only extract magic numbers when they are used more than once
        let margin: CGFloat = 16.0
        label.activate([
            label.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor, constant: 42),
            label.leadingAnchor.constraint(equalTo: safeAreaLayoutGuide.leadingAnchor, constant: margin),
            label.trailingAnchor.constraint(equalTo: safeAreaLayoutGuide.trailingAnchor, constant: margin)
        ])

        button.activate([
            button.widthAnchor.constraint(equalToConstant: 180),
            button.heightAnchor.constraint(equalToConstant: 44),
            button.centerXAnchor.constraint(equalTo: centerXAnchor),
            button.centerYAnchor.constraint(equalTo: centerYAnchor)
        ])

        stackView.activate([
            stackView.topAnchor.constraint(equalTo: button.bottomAnchor, constant: 40),
            stackView.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor)
        ])
    }
}


class DetailViewController: UIViewController {

    // MARK: Stored properties

    private lazy var detailView = DetailView()
    private var subscriptions = Subscriptions()
    private let viewModel: DetailViewModel

    init(viewModel: DetailViewModel) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func loadView() {
        view = detailView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        setup()
        setupBindings()

//        switch traitCollection.userInterfaceStyle {
//        case .light: //light mode
//            view.backgroundColor = .red
//        case .dark: //dark mode
//            view.backgroundColor = .green
//        case .unspecified:
//            view.backgroundColor = .blue
//        @unknown default:
//            fatalError()
//        }
    }

    private func setup() {

        // Setup specific to the view controller

        title = "Detail üîç"
        // tabBarItem = ...
        // supportedInterfaceOrientations = ...
    }

    private func setupBindings() {

        subscriptions.add([

            // Outputs
            viewModel.$headlineText.assign(to: \.label.text, on: detailView),
            viewModel.$buttonText.assign(to: \.button.defaultTitle, on: detailView),

            // Inputs
            detailView.button.onTap.assign(to: \.backAction, on: viewModel),
        ])
    }
}

